---
title: Thinking About Thinking With LLMs
date: 2025-09-05
tags: [ ai, llm, recurse-center, airplane-articles ]
draft: false
---

As I was putting together a [weekly newsletter](/weekly) entry for [Developing our
position on AI](https://www.recurse.com/blog/191-developing-our-position-on-ai) by the
Recurse Center, I realized that I had more than enough to say for a full blog post. Above
and beyond its findings it charts a path for a more civil and considered mode of
discussion that we should all strive for on the Internet and in our own lives.

I've long been fascinated by the Recurse Center, and throughout my career I've been
consistently impressed with its alums I've crossed paths with, so I'm not particularly
surprised that probably the most balanced and thoughtful take on AI and software
engineering that I've read so far has come out of Recurse.

## Discourse on the Internet

I think the article presents a great way to deal with contentious issues within
organizations and writing about those issues publicly. First, listen to everyone. Then,
acknowledge disagreement and emphasize nuance before outlining common ground.

The goal doesn't need to be having The Correct Take at every moment. People have different
life experiences which often leads them to different top-line beliefs. But beyond those
headlines, which can reasonably be anything from "we'll all be unemployed by 2028" to
"LLMs are slurping up all our fresh water", there is a surprising amount of common
ground in areas like how to use and not use LLMs in when trying to learn new things.

## Step-Functions in Abstractions

This paragraph from the post really resonated with me:

> [T]utorials and teachers can only get you so far. Ultimately, you must build your own
> mental structures. Stack Overflow can be a helpful resource, but blindly following or
> copy-pasting from it does little to help you learn. While you can get a lot farther
> mindlessly using LLMs than Stack Overflow, the same principle holds true.

The comparison to StackOverflow is one that I've seen pop up again and again in the
conversation around LLMs. The one-two punch of Google search and StackOverflow caused a
similar magnitude shift in our profession twenty years ago.

Google made the skill of searching and skimming manuals for reference materials almost
obsolete. O'Reilly still exists, but books are much less prevalent than blog posts,
tutorials, and other types of documentation found on the today.

StackOverflow made it possible to find code snippets to accomplish almost any common task
without much upfront thinking. This was almost always considered to be an unfortunate
shortcut. StackOverflow filled a niche, but it didn't obviate the need for a deep
understanding.

Going back even further, I'm sure folks were similarly wary to move towards higher-level
languages that abstracted away the assembly and machine code.

Much of software engineering is ultimately about automating "white collar" work previously
done by humans, whether that work is coordinating airline logistics, processing payroll,
or organizing and maintaining libraries[^1]. Programming itself has always been part of
what new software has automated, from assemblers automating the tedious process of
calculating memory offsets for jumping to procedures to garbage collectors to Google
Search to Claude Code.

[^1]: The ones filled with stacks and stacks of books, not the ones with pre-written
    functions you can call from your main program

New tools make it easier to get work done without as deep of an understanding of the
things they automate away. The addition of another tool that brings programming closer to
natural language just like C and Java and Python once did will lead to further
democratization of programming and even more people in conversation with computers.

This is a good thing! But I don't think this will change the fundamental reality that the
_best_ programmers aren't the ones that use this the highest abstractions the most
effectively. The best programmers will continue to be the ones who dig past the
abstractions to understand what's happening at a deeper level. That understanding will
always lead to more deft use of any tools that programmers have at their disposal.


