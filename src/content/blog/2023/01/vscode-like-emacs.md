---
title: "Configuring VSCode as a Keyboard-Centric IDE"
date: 2023-01-24
draft: false
tags: ["vscode", "emacs", "texteditors", "configuration"]
---

One of my first posts on this blog in 2020 was about [my experience switching from VSCode to Emacs](https://davi.sh/blog/2020/03/switching-to-emacs/) for all of my text/code editing work. I still agree with all of the benefits to Emacs I wrote about back then, and [my posts on Obsidian](https://davi.sh/blog/2022/01/obsidian-zero/) show my respect for `org-mode` as a format and the ecosystem around it – especially `org-agenda`. However, as you might have noticed when the file extension on my posts switched from `.org` back to `.md`, I've moved on from Emacs for now. But I'm happy with how I've moved my good habits back to VSCode. Spending time on config gave me more confidence in my ability to configure software I use to my liking, and make software work for me rather than make me work for the software.

At work, I'm always editing code while SSH'd into a remote machine. [TRAMP](https://www.gnu.org/software/tramp/) with [`lsp-mode`](https://github.com/emacs-lsp/lsp-mode) on a [very large C++ codebase](https://github.com/mongodb/mongo) just had too much lag for me. Even accessing Emacs compiled with native-comp running on my remote machine had way too much input delay when waiting on responses from [clangd](https://clangd.llvm.org) or [ccls](https://github.com/MaskRay/ccls), two C++ language servers. Now, it's more than possible I was [holding it wrong](https://www.wired.com/2010/06/iphone-4-holding-it-wrong/) – I do have colleagues that work all day in Emacs. But it seems like my bad UX experience was due to the [limitations of Emacs's concurrency support](https://www.gnu.org/software/emacs/manual/html_node/elisp/Threads.html) – calls to language server were blocking other interactions with the UI. On the other side of the hedge, VSCode really just works. I can still type and otherwise interact with the editor while waiting for clangd to process a request. The [remote SSH extension](https://code.visualstudio.com/docs/remote/ssh) is the state of the art. The [clangd integration](https://marketplace.visualstudio.com/items?itemName=llvm-vs-code-extensions.vscode-clangd) was plug-and-play. And I've never experienced the lag that I was feeling every day on Emacs.

While I love the smoothness of the VSCode UI, I'm not a fan of how easy it is fall back on the mouse while navigating around the editor. My favorite part of the [Doom Emacs](https://github.com/doomemacs/doomemacs) distribution was the keybindings: it made me feel like I was playing chords on the piano when splitting panes and navigating around. While I'd configured Emacs to look and feel like VSCode in my original Emacs post, I ultimately got rid of the project explorer and visual tabs to embrace more Emacs-y buffer and project management. I found myself reaching for the mouse way more often when I moved back to VSCode, putting myself at risk for RSI and generally interrupting my flow. So I set out to make my VSCode configuration as close to my Doom Emacs setup as possible. There were only a handful of changes I needed to make:

- Installed VSCode's [Vim plugin](https://marketplace.visualstudio.com/items?itemName=vscodevim.vim). I've used vim keybindings all over the place for almost four years at this point.
- Installed [VSpaceCode + WhichKey](https://vspacecode.github.io). Together, these plugins replicate the chords/leader bindings that Doom borrowed from [Spacemacs](https://www.spacemacs.org) really well. I've [remapped a few bindings](https://vspacecode.github.io/docs/menu-customization#incrementally) that were different in Doom and added a few more as well.
- Disabled [Tabs](https://code.visualstudio.com/docs/getstarted/userinterface#_tabs). Tabs are a visual abstraction that are hard to use effectively without reaching for the mouse. I got used to Emacs's buffer management, where I can fuzzy-search for recently opened files in a reverse-chronological list. VSCode's analog to buffers are called [Editors](https://code.visualstudio.com/docs/getstarted/userinterface#_open-editors) and are normally mapped on to Tabs; after disabling Tabs I can still navigate open Editors with the command "View: Show Editors in Active Group By Most Recently Used", which I've mapped to `<leader> ,` with VSpaceCode.
  - I removed tabs by adding `"workbench.editor.showTabs": false` to my `settings.json` file.
  - The command ID for "Show Editors in Active Group" is `workbench.action.showEditorsInActiveGroup`.
- Disabled the [Activity Bar](https://code.visualstudio.com/docs/getstarted/userinterface#_activity-bar). I can pull up sidebar Views like `File Explorer` and `Find in Files` with a shortcut, and dismiss them with cmd-B.
  - Add `"workbench.activityBar.visible": false` to your `settings.json`.

The fact that VSCode can do all this is a testament to its extensability and the power of a more limited but still deep [plugin API](https://code.visualstudio.com/api). A `settings.json` file is no match for `init.el` when it comes to expressiveness, but I've still been able to mold VSCode into an editor that I feel at home using.

![Configured VSCode Screenshot](/blog/images/vscode-screenshot.png)

I'm sure I'll keep playing around with Emacs going forward, but the all-consuming nature of the Emacs philosophy – the idea that everything from email to web browsing to journaling should happen inside Emacs – doesn't resonate with me in practice. I can use VSCode for most of my development, Obsidian for editing Markdown, and even PyCharm for Python/Django development (check out [intellimacs](https://github.com/MarcoIeni/intellimacs) for JetBrains IDEs if you're interested in my setup there). With just a few hours of set-up, I can use the right tool for the job and still feel at home regardless.
