---
title: "CIS188 Guest Lecture: Databases"
---

This is a slide deck on databases!

{% slide type="title" title="Distributed Databases"%}
By Davis Haupt
{% /slide %}

I've been at MongoDB since August. In that time, I've rotated on the SQL engines team, working on a SQL-to-MongoDB compiler for compatibility with existing SQL tooling. I ended up on the Query Optimization team, which is building out a new query optimization engine for the MongoDB query language.

{% slide title="Agenda"%}
### 00: What is a Database?
CIS450 in 5 minutes.
### 01: Data Models & Query Patterns
Comparing Postgres & MongoDB.
### 02: Distributed Databases
Database architecture and scalability.
### 03: Where Next?
The direction the industry is moving in.
{% /slide %}
The topic of this lecture is "Distributed Databases," but I'm not assuming anyone here's taken CIS450 (I never took it myself), so we'll start off closer to the beginning of the story.


{% slide type="point" title="What is a database?" %}
> An organized collection of structured, queryable information (paraphrased from Oracle.com)
{% /slide %}

A filesystem might contain tons of structured JSON files, but filesystems don't have the capacity to query for data by anything except for filepath (which is basically an ID). Being able to store information AND get it back out again are key components of a database.

{% slide title="Examples" %}
- MySQL
	- Relational SQL
- Apache Cassandra
	- Column-oriented and distributed
- Redis
	- In-memory datastore & cache layer
{% /slide %}

You've used Redis throughout this class. Its homepage describes it as an "in-memory data store" that can be used "as a database, cache, streaming engine and message broker"

{% slide title="Structured Query Language" %}
- Developed at IBM for System R in 1974
- Declarative
- Relational Lingua Franca
{% /slide %}
Since the 1980s, the dominant database management systems have followed the relational model and over time have standardized on the Structured Query Language, which goes by its acronym SQL (pronounced like the word "sequel"). SQL was designed to be declarative to make it easy for database administrators to access data without worrying about the underlying execution plan. We'll see some examples of SQL in the next few slides.

Relational DBs are also called SQL databases, since today, the query language and the relational model often go hand-in-hand. These terms will be used interchangeably throughout the talk.

{% slide title="The SQL Standard" %}
![xkcd standards](https://imgs.xkcd.com/comics/standards.png)
{% /slide %}
SQL's been standardized since the late 80s, but at that point it had already been defined by its implementations for about a decade. Even though SQL:2016 added native support for JSON, Postgres and other databases built in their own support with their own syntax beforehand. That's even before considering the procedural extensions built on top.

SQL-92 is the last, truly standard SQL specification that has come out.


{% slide title="PostgreSQL" %}
The most popular database that isn't owned & operated by EvilCorp
{% /slide %}
For this talk, we'll be focusing on Postgres's flavor of SQL for simplicity's sake, since it's one of the most popular databases among developers.

{% slide title="!SQL" %}
Because developers love to be contrarian.
{% /slide %}
All SQL databases use the same query language and data model and can be directly compared to each other. 

By comparison, NoSQL encompasses the universe of everything else that’s out there. It’s an incredibly broad label that can refer to any database system that doesn't use SQL as its query language. 

This generally maps on to the concept of "non-relational" databases, but even this is extremely broad, covering everything from column stores like Cassandra, to key/value stores like Redis, and document databases like MongoDB and Fauna.

{% slide title="Our Comparison Today" %}
MongoDB + Postgres
{% /slide %}
All of these databases are optimized for different use cases, but for the sake of time and all of our sanities today, we'll be focusing on MongoDB, a document database, and its query language, MQL. The smaller but still broad category of document database also includes RedisJSON, Couchbase, Fauna, and Amazon DocumentDB, to name a few.

SQL is standard enough that even though I'm showing Postgres queries, the queries may very well run unmodified on a bunch of other SQL databases.

Document databases don't share any query language, so all the Mongo queries will be pretty specific to Mongo.

{% slide title="Databases: What are they good for?" %}
- **C**reate
- **R**etrieve
- **U**pdate
- **D**elete
{% /slide %}
Almost every application that uses a database handles four basic operations commonly called the CRUD operations: Create, Retrieve, Update, and Delete. Some apps are "read heavy" while others are "write heavy". The rates at which different operations are performed is one of the main things that can inform the choice of database and data model.

{% slide title="A data modeling case study" %}
### "Cornell Course Cart" (C3)
Users can:
- View review for a given course
- Add courses to a cart
{% /slide %}
No matter what kind of database you use, you'll have to design a data model for your application. This is a description of the information you're storing in your database, and how different pieces of information are related to each other. Throughout this talk, we'll use the example of a completely hypothetical course review system I'll call the Cornell Course Cart, or C3. 

Users of this site can perform two actions:
1. View reviews for courses.
2. Add courses to their course cart.

{% slide title="Data modeling: relationships" %}

### One-to-one
A user has one cart.

### One-to-many
A course can have multiple sections, but each section belongs to one course.

### Many-to-many

A user's cart can contain many courses, and a course can be in many different users' carts.

{% /slide %}

In any data model, there's three fundamental types of relationship among different pieces of data. On this slide, you can see each relationship type along with an example from the C3 application.


{% slide title="Storing data in SQL" %}
- Data is stored in **tables**
- Each entry is a **row**, and every attribute is a **column**
- Each table has a _fixed_ set of columns known as its **schema**.
Data is modeled primarily through the _relationships_ between tables.

{% /slide %}

Like its name suggests, relational databases put the relations between tables front-and-center.

{% slide title="Building a relational schema" %}

TODO: SQL tables

{% /slide %}

Since tables are flat and must have a fixed set of columns, complex applications build up their data model from many tables that have relationships (called foreign keys) between them. With C3, this is what our schema would look like.
If I want to find out which class a student registered for instead of CIS189, I can follow the section_id field to the corresponding row on the SECTIONS table, and then follow that row's course_id to the COURSES table, where I'll find the name and number for the course.

A key property you'll notice of this database schema is that there's no duplicated data anywhere. The only place you can find a course's title is in the COURSE table. The only place to find which professors teach a class is in each SECTION table.

This is a sign that the database is properly normalized. Eliminating data redundancy makes managing and updating data much easier, since any piece of information only needs to be updated in one row, in one table. compared to a duplicated or denormalized data model. It's the recommended way to store data in a relational database when starting out.

{% slide title="Storing data in MongoDB" %}
- Data stored in ***collections***.
- Each entry is a ***document***, and every attribute is a ***field***.
- Every document in a collection _can_ have a ***flexible schema***.
- Like JSON, documents can contain ***nested fields*** and ***arrays of subobjects***, which are the natural way to express most relationships in the document model.
{% /slide %}

{% slide title="Building a non-relational schema" %}

{% /slide %}

You can see here that one-to-many relationships, which required foreign keys in the relational schema, are expressed naturally as nested sub-documents within an array.

These documents can be easily serialized as JSON hand handled by any client programming language that has a JSON parser.

What is expressed a bit more awkwardly, though, is the course cart. What would happen if a course changed its number, or title?

The user<->course relationship is a many-to-many relationship, and the way I've decided to represent the cart has resulted in some data duplication. This makes it fast and easy to access both a user's cart and a course's info, but it requires updating the information in two places if it ever changes. This is called denormalization, and it's a natural pattern in non-relational databases.


{% slide title="Querying Postgres" %}
#### Key Takeaway: JOINs
```js
select *
from COURSES
  inner join SECTIONS on 
    SECTIONS.course_id = COURSES.id
  inner join REVIEWS on 
	SECTIONS.review_id = REVIEWS.id
where
   COURSES.department = “CIS”
   and COURSES.course_code = “188”
```
{% /slide %}

{% slide title="Querying MongoDB" %}
```js
db.courses.find({
	department: "CIS", 
	course_number: "188"
});
```
{% /slide %}

{% slide title="Querying MongoDB" %}

```js
db.courses.find({
	department: "CIS",
	section.number: "005"
});
```

{% /slide %}

{% slide title="Updating Postgres" %}

```sql
begin;
update SECTIONS set professor = "Campbell Phalen"
  inner join COURSES on 
    SECTIONS.course_id = COURSES.id
  where COURSES.department = "CIS"
    and COURSES.course_number = "188"
    and SECTIONS.professor = "Armaan Tobaccowalla"
update SECTIONS set professor = "Rohan Gupta"
  inner join COURSES on 
    SECTIONS.course_id = COURSES.id
  where COURSES.department = "CIS"
    and COURSES.course_number = "188"
    and SECTIONS.professor = "Peyton Walters"
commit;
```

{% /slide %}

{% slide title="Updating MongoDB" %}
```js
db.courses.updateOne(
  {department: "CIS", course_code: "188"},
  {$set: {
    "sections.$[peyton].professor": "Rohan Gupta",
    "sections.$[armaan].professor": "Campbell Phalen"
  }},
  {arrayFilters: [
    {"peyton": {
      "sections.professor": "Peyton Walters"
	}},
    {"armaan": {
	"sections.professor": "Armaan Tobaccowalla"
	}},
  ]}
);
```
{% /slide %}

{% slide title="Data normalization for data entry" %}
- Any piece of information will only exist in one place.
- Applications need to be able to operate over entire
logical entities that are made up from multiple tables.
- Joins help with reading, transactions with writing.
{% /slide %}

{% slide title="Data denormalization for data access" %}
- Information is duplicated in multiple places so it can be read with other data it is commonly accessed with.
- Application must update information in all places on writes.
- At the largest scales, virtually all data schemas are denormalized. Joins are too expensive on huge tables.
{% /slide %}

{% slide title="These days, all the top databases are multi-model." type="point"%}

{% /slide %}

{% slide title="Semi-structured Data in Postgres" %}
```sql
SELECT jdoc->'department', jdoc->'course_code'
    FROM api WHERE jdoc @> '{"department": "CIS"}';
```
{% /slide %}

{% slide title="Joins and Transactions in MongoDB" %}
```js
db.users.aggregate([
    {$match: {name: "Campbell Phalen"}},
    {$unwind: "$cart.courses"},
    {$lookup: {
      from "courses",
      let:  {department: "$department",
             course_number: "$course_number"},
        pipeline: [
            {$match: {
                department: "$$department",
                course_number: "$$course_number"}
}] }}
])
```
{% /slide %}

{% slide title="Recap!" %}
### SQL Databases
Data is most naturally stored in normalized, de-duplicated flat tables, regardless of access pattern.

### MongoDB
Data is most naturally stored how objects are accessed by applications.
{% /slide %}

{% slide title="Recap!" %}
### SQL Databases
Rely more heavily on joins to ***read normalized data*** into a usable form by the application.

### MongoDB
Can de-emphasize joins and ***write denormalized data*** how it will eventually be used.
{% /slide %}

{% slide title="The secret ingredients in the Web Scale sauce" %}
### High Availability
### Horizontal Scaling
{% /slide %}

{% slide title="High Availability" %}
## Replication
- Store copies of data on multiple nodes in case of node failure
- All queries to the replica set can be answered by a single node
- Low-latency reads with replicas in different regions
{% /slide %}

{% slide title="Horizontal Scaling" %}
## Sharding
- Split data among multiple nodes to increase throughput & storage capacity.
- Queries may need to touch multiple nodes to get a full answer.
- Low-latency reads and writes with shards in different regions (data locality).
{% /slide %}

{% slide title="A note on application-level scaling" %}
- Facebook was sharding their MySQL fleet as early as 2005.
- The goal of all databases is to push shared operational complexity down the stack away from the application
{% /slide %}

{% slide title="A short history of distributed databases" %}
- 2007: Amazon Dynamo Paper
- 2009: MongoDB 1.0 Released
- 2012: Spanner Paper
- 2016: Vitess 2.0 adds cross-shard joins on top of MySQL
- 2017: CockroachDB 1.0 Released
- 2017: Postgres adds native logical replication
{% /slide %}

{% slide title="A short history of distributed databases" %}
- 2007: Amazon Dynamo Paper (NoSQL)
- 2009: MongoDB 1.0 Released (NoSQL)
- 2012: Spanner Paper (SQL-ish)
- 2016: Vitess 2.0 adds cross-shard joins on top of MySQL (SQL)
- 2017: CockroachDB 1.0 Released (SQL)
- 2017: Postgres adds native logical replication (SQL)
{% /slide %}

{% slide title="What’s hard about distributed SQL?" %}
- Joins
- Transactions
{% /slide %}

{% slide title="What’s hard about distributed SQL?" %}
It’s easier to scale/shard denormalized datasets, whether it happens inside or outside of the database.
{% /slide %}

{% slide title="NewSQL" %}
- Cloud Spanner
- CockroachDB
- Vitess (PlanetScale)
- YugabyteDB
- NuoDB
- VoltDB
{% /slide %}

{% slide title="Where are we going from here?" type="title" %}

To the ~~moon~~ cloud

{% /slide %}

{% slide title="Tuning, operating, indexing, and managing databases is hard" %}
## Database Administrator
A whole profession specializing in DBMS management.
{% /slide %}

{% slide title="Managed Services" %}
- Amazon RDS Dedicated (2009)
- DynamoDB (2012)
- MongoDB Atlas Dedicated (2016)
- CockroachDB Dedicated (2019)
- PlanetScale (2021)
{% /slide %}

{% slide title="You’re still renting virtual hardware" %}

{% /slide %}

{% slide title="The Cloud is a leaky abstraction." type="point" %}

{% /slide %}

{% slide title="Amazon DynamoDB" %}
### Cloud-only
No self-hostable version

### Distributed
Data is partitioned & replicated

### Auto-scaling

### Pay for usage
Not compute resources
{% /slide %}

{% slide title="Serverless billing model" %}
### Cloud-only
No self-hostable version

### Distributed
Data is partitioned & replicated

### Auto-scaling

### Pay for usage
Not compute resources
{% /slide %}

{% slide title="Serverless Offerings" %}
- DynamoDB (2012)
- Firebase (2012)
- Fauna (2017)
- MongoDB (Beta 2021)
- CockroachDB (Beta 2021)
- PlanetScale (2021)
{% /slide %}

{% slide title="Thanks!" type="title" %}
### Questions?
davis@davishaupt.com
{% /slide %}